go的内存分配基于tcmalloc
TCMalloc 是 Google 开发的内存分配器，在不少项目中都有使用，例如在 Golang 中就使用了类似的算法进行内存分配。
它具有现代化内存分配器的基本特征：对抗内存碎片、在多核处理器能够 scale。据称，它的内存分配速度是 glibc2.3 中实现的 malloc的数倍。
之所以学习 TCMalloc，是因为在学习 Golang 内存管理的时候，发现 Golang 竟然就用了鼎鼎大名的 TCMalloc


• 从 mmap 申请大块内存,自主管理,减少系统调用用。
• 基于块的内存复用用体系,加快内存分配和回收操作。
分配器以⻚为单位向操作系统申请大块内存。这些大块内存由 n 个地址连续的⻚页组成,并
用用名为 span 的对象进行管理。


• heap: 全局根对象。负责向操作系统申请内存,管理由垃圾回收器收回的空闲 span 内
存块。
• central: 从 heap 获取空闲 span,并按需要将其切分成 object 块。heap 管理着多个
  central 对象,每个 central 负责处理一一种等级的内存分配需求。
• cache: 运行行期,每个 cache 都与某个具体线程相绑定,实现无无锁内存分配操作。其内
  部有个以等级为序号的数组,持有多个切分好的 span 对象。缺少空间时,向等级对应
  的 central 获取新的 span 即可。


分配流程:
• 通过 size class 反查表计算待分配对象等级。
• 从 cache.alloc[sizeclass] 找到等级相同的 span。
• 从 span 切分好的链表中提取可用用 object。
• 如 span 没剩余空间,则从 heap.central[sizeclass] 找到对应 central,获取 span。
• 如 central 没可用用 span,则向 heap 申请,并切割成所需等级的 object 链表。
• 如 heap 也没有多余 span,那么就向操作系统申请新的内存。
回收流程:
• 垃圾回收器或其他行行为引发内存回收操作。
• 将可回收 object 交还给所属 span。
• 将 span 交给对应 central 管理,以便某个 cache 重新获取。

• 如 span 内存全部收回,那么将其返还给 heap,以便被重新切分复用用。
• 垃圾回收器定期扫描 heap 所管理的空闲 spans,释放超期不用用的物理内存。
从 heap 申请和回收 span 的过程中,分配器会尝试合并地址相邻的 span 块,以形成更
大大内存块,减少碎片片。

初始化是巨大的虚拟地址空间

arena 用户内存实际分配范围
bitmap  4bit标记位 用于垃圾回收
spans   每个页所对应的span地址


内存地址预留操作通过 mmap PORT_NONE 实现。不过,在 darwin/OSX 中,并未使
用用 MAP_FIXED 参数,因此未必从 0xc000000000 开始。


其中,free 和 busy 数组以 span ⻚页数为序号管理多个链表。当 central 有需要时,只需
从 free 找到⻚页数合适的链表,从中提取可用用 span 即可。busy 记录的自自然是已经被使用用
的 span。
至至于 large 链表,用用于保存所有超出 free/busy ⻚页数限制的 span。

其中,free 和 busy 数组以 span ⻚页数为序号管理多个链表。当 central 有需要时,只需
从 free 找到⻚页数合适的链表,从中提取可用用 span 即可。busy 记录的自自然是已经被使用用
的 span。
至至于 large 链表,用用于保存所有超出 free/busy ⻚页数限制的 span。


至于 central,同样是完成两个 span 管理链表的初始化操作。其中 nonempty 链表保存
有剩余 object 空间,等待被 cache 获取的 span。而而 empty 则保存没有剩余空间或已
被 cache 获取的 span。

• 尽可能将微小小对象组合到一一个 16 字节的 tiny 块中,据说可提高高性能。
• 小小对象从 cache.alloc[] 找到等级相同的 span,并从其 freelist 链表获取 object。
• 大大对象直接从 heap 分配。

除基本的分配操作外,还需要关注内存不足足时的 “扩张” 过程。这需要一一点耐心心和细心心。
首首先,当 cache.alloc[] 中对应的 span 没有剩余 object 时,会触发从 central 获取新
span 操作。

需要提前说明一一点背景知识:从 Go 1.3 开始,垃圾回收算法就有很大大变动。其中标记阶
段需要执行行 StopTheWorld,然后用用多线程并发执行行标记操作。待标记结束后,立立即恢复
StartTheWorld,用用单独的 goroutine 执行行清理操作。
因此在执行行 CacheSpan 时,某些 span 可能还未完成清理。此时主动触发回收操作,有
助于提高高内存复用用率,避免向操作系统过度申请内存。


相比比 Go 1.3,cache 部分又又做了很大大的改进。代码更加简洁,流程也更加清晰。
而而当 central 空间不足足时,就需要从 heap 获取新 span 来完成扩张操作。这其中就包括
对 span 所管理内存进行行切分,形成 object freelist 链表。


cache -->  heap --->pergen


从 heap 获取 span 算法:
• 以⻚页数为序号,从 free[] 提取链表,从中返回可用用 span。
• 如链表为空,则继续从页数更大大的链表中查找。
• 如 free[] 所有链表均没找到可用用 span,就从 freelarge 链表中提取。
• 直到向操作系统申请新的 span 块。



当找到的 span 大大小小超出预期时,分配器会执行行切割操作,将多余的内存做成新 span 放
回 heap 管理链表中。
从 large 里里查找 span 的算法被称作 BestFit。很简单,通过循环遍历,找到大大小小最合适
的目标。

在此,我们看到了 heap.spans 的作用用。合并零散内存块,以提供更大大复用用空间,这有助
于减少内存碎片片,是内存管理算法的一一个重要设计⺫目目标。
最后,就是剩下如何向操作系统申请新的内存了

垃圾回收器通过调用用 MSpan_Sweep 函数完成内存回收操作。
该回收函数在分配流程 CacheSpan 中也曾提及过。
大大对象释放很简单,调用用 FreeSpanLocked 将 span 重新放回 heap 管理链表即可。




垃圾回收 经典的标记清除

当分配 (malloc) 总量超出预设阈值,就会引发垃圾回收。操作前,须暂停用户逻辑执行
(StopTheWorld),然后启用用多个线程执行行并行行扫描工作,直到标记出所有可回收对象。
垃圾回收的域值成倍增长

从 Go 1.3 开始,默认采用用并发内存清理模式。也就是说,标记结束后,立即恢复逻辑执
行行 (StartTheWorld)。用用一个专门的 goroutine 在后台清理内存。这缩短了暂停时间,
在一定程度上改善了垃圾回收所引发的问题。

完成清理后,新阈值通常是存活对象所用用内存的 2 倍。需要注意的是,清理操作只是调用用
内存分配器的相关方方法,收回不可达对象内存进行行复用用,并未释放物理内存。

物理内存释放由专⻔门线程定期执行行。它检查最后一一次垃圾回收时间,如超过 2 分钟,则执
行强制回收。还会让操作系统收回闲置超过 5 分钟的 span 物理内存




